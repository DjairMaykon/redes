## Projetos de Redes: Comunica√ß√£o Cliente-Servidor com Sockets em C

Este reposit√≥rio cont√©m dois projetos de redes, implementando comunica√ß√£o cliente-servidor utilizando sockets em C. Al√©m disso, h√° uma pasta dedicada √† an√°lise de desempenho, com scripts em Python para avaliar m√©tricas como throughput e bandwidth.

---

## Estrutura do Reposit√≥rio

```
üì¶
‚îú‚îÄ‚îÄ p1/                # Projeto 1: Sistema Cliente-Servidor de listagem de diret√≥rios do cliente
‚îú‚îÄ‚îÄ p2/                # Projeto 2: TO-DO
‚îú‚îÄ‚îÄ analise/           # Scripts para an√°lise de desempenho
‚îî‚îÄ‚îÄ README.md          # Este arquivo
```

---

### **Projeto 1 (`p1/`)**
#### Descri√ß√£o
Este projeto implementa um sistema cliente-servidor em C. A funcionalidade principal √© transferir uma lista de nome de arquivos de um diret√≥rio especificado do cliente para o servidor, que salva os arquivos em um √∫nico arquivo consolidado.

#### **Funcionamento**
- **Cliente**:
  - Recebe como argumento o caminho de um diret√≥rio contendo arquivos.
  - Envia a lista de arquivos ao servidor utilizando sockets.
  
- **Servidor**:
  - Recebe a lista de arquivos do cliente.
  - Salva os dados recebidos em um arquivo local.

Aqui est√° o Makefile atualizado para que voc√™ escolha explicitamente entre compilar para Windows ou Linux ao inv√©s de o script detectar o sistema operacional automaticamente:

### Makefile

```makefile
# Nome dos execut√°veis
CLIENTE_EXEC = cliente
SERVIDOR_EXEC = servidor

# Fontes
CLIENTE_SRC = cliente.c
SERVIDOR_SRC = servidor.c

# Compilador e flags
CC = gcc
CFLAGS = -Wall -O2

# Extens√µes para Windows
WINDOWS_SUFFIX = .exe
WINDOWS_FLAGS = -lws2_32

# Extens√µes para Linux
LINUX_SUFFIX =
LINUX_FLAGS = 

# Vari√°veis de ambiente para plataforma
PLATFORM ?= linux

# Configura√ß√£o baseada na plataforma
ifeq ($(PLATFORM), windows)
    EXEC_SUFFIX = $(WINDOWS_SUFFIX)
    EXTRA_FLAGS = $(WINDOWS_FLAGS)
else
    EXEC_SUFFIX = $(LINUX_SUFFIX)
    EXTRA_FLAGS = $(LINUX_FLAGS)
endif

# Alvos principais
all: $(CLIENTE_EXEC)$(EXEC_SUFFIX) $(SERVIDOR_EXEC)$(EXEC_SUFFIX)

# Compilar cliente
$(CLIENTE_EXEC)$(EXEC_SUFFIX): $(CLIENTE_SRC)
	$(CC) $(CFLAGS) $(EXTRA_FLAGS) -o $@ $<

# Compilar servidor
$(SERVIDOR_EXEC)$(EXEC_SUFFIX): $(SERVIDOR_SRC)
	$(CC) $(CFLAGS) $(EXTRA_FLAGS) -o $@ $<

# Executar cliente
run-cliente:
	./$(CLIENTE_EXEC)$(EXEC_SUFFIX)

# Executar servidor
run-servidor:
	./$(SERVIDOR_EXEC)$(EXEC_SUFFIX)

# Limpeza
clean:
	rm -f $(CLIENTE_EXEC)$(EXEC_SUFFIX) $(SERVIDOR_EXEC)$(EXEC_SUFFIX)
```

---

### Atualiza√ß√£o do README

#### **Compila√ß√£o e Execu√ß√£o com Makefile**

1. Certifique-se de ter o GNU Make e o compilador `gcc` instalados.
   - **Ubuntu**: `sudo apt install build-essential`
   - **Windows**: Use o **MinGW** ou outra distribui√ß√£o compat√≠vel.

2. Navegue at√© a pasta `p1`:
   ```bash
   cd p1
   ```

3. Escolha a plataforma para compila√ß√£o:
   - Para Linux:
     ```bash
     make PLATFORM=linux
     ```
   - Para Windows:
     ```bash
     make PLATFORM=windows
     ```

4. Execute os programas:
   - Para o servidor:
     ```bash
     make run-servidor
     ```
   - Para o cliente:
     ```bash
     make run-cliente
     ```

5. Limpe os arquivos gerados:
   ```bash
   make clean
   ```

---

### **Projeto 2 (`p2/`)**
- **Status**: TO-DO
- **Descri√ß√£o**: Implementa√ß√£o futura a ser definida.

---

### **An√°lise (`analise/`)**
- **Status**: TO-DO
- **Descri√ß√£o**: Implementa√ß√£o futura a ser definida.
